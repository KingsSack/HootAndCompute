---
title: Creating your first Attachment
description: Learn to create your first Attachment with Volt.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

An `Attachment` represents a distinct subsystem of your `Robot`, such as an intake, a claw, or an arm. The `Attachment` base class provides a powerful structure for managing state, creating `Action`s, and displaying telemetry, all of which are automatically handled by your `Robot` class.

An `Attachment` can be shared by multiple `Robot`s.

## Guide

This guide will walk you through the process of setting up your own `Attachment`.

There should be one `Attachment` per "interaction" your `Robot` can perform.

:::caution

This page goes over creating your own `Attachment` from the abstract base class, which isn't always necessary.

See [Built-In Attachments](../05-built-in-attachments) to learn more.

:::

### 1. Create Your `Attachment` Class

First, create a new class that inherits `Attachment`.
The constructor requires a `name` for the attachment, which is used as an identifier and for logging telemetry.
This `name` should be unique for each `Attachment` you create.
You should also pass in any hardware devices this subsystem will control.

<Tabs>

<TabItem label="Kotlin">

```kotlin
import com.qualcomm.robotcore.hardware.Servo
import dev.kingssack.volt.attachment.Attachment

class Claw(private val claw: Servo) : Attachment("Claw") {
    // Attachment logic will go here
}
```

</TabItem>

<TabItem label="Java">

```java
import com.qualcomm.robotcore.hardware.Servo;
import dev.kingssack.volt.attachment.Attachment;

class Claw extends Attachment {
    private Servo claw;

    public Claw(Servo claw) {
        super("Claw");
        this.claw = claw;
    }

    // Attachment logic will go here
}
```

</TabItem>

</Tabs>

### 2. The `update()` Method

The `Robot` class automatically calls the `update()` method on every registered attachment during each tick of your OpMode.

The base `Attachment` already implements `update()`  to add telemetry about the attachment's state
(`Idle`, `Running`, or `Fault`).
If you need continuous logic or custom telemetry, you can override this method.

In this example, we'll log the claw's current position:

<Tabs>

<TabItem label="Kotlin">

```kotlin {6-10}
import com.qualcomm.robotcore.hardware.Servo
import dev.kingssack.volt.attachment.Attachment
import org.firstinspires.ftc.robotcore.external.Telemetry

class Claw(private val claw: Servo) : Attachment("Claw") {
    context(telemetry: Telemetry)
    override fun update() {
        super.update()
        telemetry.addData("Position", claw.position)
    }
}
```

</TabItem>

<TabItem label="Java">

```java {14-18}
import com.qualcomm.robotcore.hardware.Servo;
import dev.kingssack.volt.attachment.Attachment;
import org.firstinspires.ftc.robotcore.external.Telemetry;
import org.jetbrains.annotations.NotNull;

class Claw extends Attachment {
    private Servo claw;

    public Claw(Servo claw) {
        super("Claw");
        this.claw = claw;
    }

    @Override
    public void update(Telemetry telemetry) {
        super.update(telemetry);
        telemetry.addData("Position", claw.getPosition());
    }
}
```

</TabItem>

</Tabs>

### 3. State Management

Every `Attachment` has a state, which is managed automatically when using `Action`s. The possible states are:

- `Idle`: The `Attachment` is not executing an `Action`.
- `Running`: The `Attachment` is executing an `Action`.
- `Fault(val error: Throwable)`: An error has occurred.

The `Attachment` class provides helper functions to check the current state:

- `isBusy()`: Returns `true` if the state is `Running`.
- `isFaulted()`: Returns `true` if the state is `Fault`.
- `requireReady()`: Throws an exception if the attachment is not `Idle`. This is useful for preventing new commands from starting while one is already running.

### 4. Creating Actions

The most powerful feature of an `Attachment` is the `action` builder,
which simplifies the creation of stateful, multi-step tasks.
This is perfect for commands like "open the claw,"
"move the arm to a position," or "run the intake for a number of seconds."

The `action` builder creates an `Action` and automatically manages the attachment's state (`Running` -> `Idle`/`Fault`), including robust error handling.

The builder has three main parts:

- `init { }`: This block runs **once** when the action begins. Use it for setup tasks, like setting a motor's target position of moving a servo.
- `loop { }` This block runs **until it returns `true`**. The main logic of your `Action` goes here. Return `false` to continue the `Action`, or `true` to complete the  `Action`.
- `cleanup { }`: This block runs **once** after the `loop` finishes or if an error occurs. Use it to reset hardware to a safe state, like turning off a motor.

Let's create `open()` and `close()` `Action`s for the `Claw`:

<Tabs>

<TabItem label="Kotlin">

```kotlin {7-32}
import com.acmerobotics.roadrunner.Action
import com.qualcomm.robotcore.hardware.Servo
import dev.kingssack.volt.attachment.Attachment
import org.firstinspires.ftc.robotcore.external.Telemetry

class Claw(private val claw: Servo) : Attachment("Claw") {
    private val OPEN_POSITION = 0.8
    private val CLOSED_POSITION = 0.3

    fun open(): Action = action {
        init {
            requireReady() // Require attachment to be idle
        }

        loop {
            claw.position = OPEN_POSITION
            true // Return true because the action is complete
        }

        // No cleanup required
    }

    fun open(): Action = action {
        init {
            requireReady()
        }

        loop {
            claw.position = CLOSED_POSITION
            true
        }
    }

    context(telemetry: Telemetry)
    override fun update() {
        super.update()
        telemetry.addData("Position", claw.position)
    }
}
```

</TabItem>

<TabItem label="Java">

```java {8-9} {18-36}
import com.acmerobotics.roadrunner.Action;
import com.qualcomm.robotcore.hardware.Servo;
import dev.kingssack.volt.attachment.Attachment;
import org.firstinspires.ftc.robotcore.external.Telemetry;
import org.jetbrains.annotations.NotNull;

class Claw extends Attachment {
    private static final double OPEN_POSITION = 0.8;
    private static final double CLOSED_POSITION = 0.3;

    private Servo claw;

    public Claw(Servo claw) {
        super("Claw");
        this.claw = claw;
    }

    public Action open() {
        return action(() -> {
            requireReady(); // Require attachment to be idle
        }, () -> {
            claw.setPosition(OPEN_POSITION);
            return true; // Return true because the action is complete
        }, () -> {
            // No cleanup required
        });
    }

    public Action close() {
        return action(() -> {
            requireReady();
        }, () -> {
            claw.setPosition(CLOSED_POSITION);
            return true;
        });
    }

    @Override
    public void update(Telemetry telemetry) {
        super.update(telemetry);
        telemetry.addData("Position", claw.getPosition());
    }
}
```

</TabItem>

</Tabs>

In this example, when the `Action` built by either `open()` or `close()` is executed,
the attachment's state to `Running`, execute the logic, and then set the state back to `Idle` upon completion.

### 5. Using Attachments in Your Robot

Once your `Attachment` is defined, you can instantiate it in your `Robot` class.
The `Robot` will automatically discover it and handle `update()` method.

<Tabs>

<TabItem label="Kotlin">

```kotlin
class MyRobot(hardwareMap: HardwareMap) : Robot(hardwareMap) {
    private val clawServo by servo("cs")

    val claw = Claw(clawServo)
}
```

</TabItem>

<TabItem label="Java">

```java
public class MyRobot extends Robot {
    private Servo clawServo;
    
    public Claw claw;

    public MyRobot(hardwareMap: HardwareMap) {
        super(hardwareMap);
        clawServo = hardwareMap.get(Servo.class, "cs");
        claw = new Claw(clawServo);
    }
}
```

</TabItem>

</Tabs>

## Result

<Tabs>

<TabItem label="Kotlin">

```kotlin
package org.firstinspires.ftc.teamcode.attachment

import com.acmerobotics.roadrunner.Action
import com.qualcomm.robotcore.hardware.Servo
import dev.kingssack.volt.attachment.Attachment
import org.firstinspires.ftc.robotcore.external.Telemetry

class Claw(private val claw: Servo) : Attachment("Claw") {
    private val OPEN_POSITION = 0.8
    private val CLOSED_POSITION = 0.3

    fun open(): Action = action {
        init { requireReady() }

        loop {
            claw.position = OPEN_POSITION
            true
        }
    }

    fun open(): Action = action {
        init { requireReady() }

        loop {
            claw.position = CLOSED_POSITION
            true
        }
    }

    context(telemetry: Telemetry)
    override fun update() {
        super.update()
        telemetry.addData("Position", claw.position)
    }
}
```

</TabItem>

<TabItem label="Java">

```java
package org.firstinspires.ftc.teamcode.attachment;

import com.acmerobotics.roadrunner.Action;
import com.qualcomm.robotcore.hardware.Servo;
import dev.kingssack.volt.attachment.Attachment;
import org.firstinspires.ftc.robotcore.external.Telemetry;
import org.jetbrains.annotations.NotNull;

class Claw extends Attachment {
    private static final double OPEN_POSITION = 0.8;
    private static final double CLOSED_POSITION = 0.3;

    private Servo claw;

    public Claw(Servo claw) {
        super("Claw");
        this.claw = claw;
    }

    public Action open() {
        return action(() -> {
            requireReady();
        }, () -> {
            claw.setPosition(OPEN_POSITION);
            return true;
        });
    }

    public Action close() {
        return action(() -> {
            requireReady();
        }, () -> {
            claw.setPosition(CLOSED_POSITION);
            return true;
        });
    }

    @Override
    public void update(Telemetry telemetry) {
        super.update(telemetry);
        telemetry.addData("Position", claw.getPosition());
    }
}
```

</TabItem>

</Tabs>
