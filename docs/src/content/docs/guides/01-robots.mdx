---
title: Creating your first Robot
description: Learn to create your first Robot with Volt.
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

The `Robot` class is the heart of your robot's code. It serves as a centralized container for all your hardware devices and subsystems (attachments), providing a clean structure and powerful features to simplify your code.

## Guide

This guide will walk you through the process of setting up your own `Robot`.

You should create a new `Robot` class for each type of physical robot you've built.

### 1. Create Your `Robot` Class

First, create a new class that inherits from the abstract `Robot` class.
This class requires a `HardwareMap` (from an OpMode) to be passed to its constructor.

<Tabs>

<TabItem label="Kotlin">

```kotlin
import com.qualcomm.robotcore.hardware.HardwareMap
import dev.kingssack.volt.robot.Robot

class MyRobot(hardwareMap: HardwareMap) : Robot(hardwareMap) {
    // Your hardware and attachments will be defined here
}
```

</TabItem>

<TabItem label="Java">

```java
import com.qualcomm.robotcore.hardware.HardwareMap;
import dev.kingssack.volt.robot.Robot;

public class MyRobot extends Robot {
    // Your hardware and attachments will be defined here

    public MyRobot(hardwareMap: HardwareMap) {
        super(hardwareMap);
    }
}
```

</TabItem>

</Tabs>

### 2. Defining Hardware

Volt uses Kotlin's property delegation to make hardware initialization clean and concise.
Instead of calling `hardwareMap.get()` for every device, you can use the helper functions provided by the `Robot` class.

To define a device, use the `by` keyword followed by the appropriate helper function,
passing the device name as configured in your robot's hardware configuration.

Here are some of the available helper functions:

- `motor(name: String)` for `DcMotor`
- `servo(name: String)` for `Servo`
- `crServo(name: String)` for `CRServo`
- `imu(name: String)` for `IMU`
- `huskyLens(name: String)` for `HuskyLens`
- `distanceSensor(name: String)` for `Rev2mDistanceSensor`
- `colorSensor(name: String)` for `NormalizedColorSensor`
- `analogInput(name: String)` for `AnalogInput`

<Tabs>

<TabItem label="Kotlin">

```kotlin {5-9}
import com.qualcomm.robotcore.hardware.HardwareMap
import dev.kingssack.volt.robot.Robot

class MyRobot(hardwareMap: HardwareMap) : Robot(hardwareMap) {
    // Motors
    private val motor1 by motor("m1")

    // Sensors
    private val imu by imu("imu")
}
```

</TabItem>

<TabItem label="Java">

Java does not support these helper methods, so it has to use `hardwareMap.get()`.

```java {5-9, 13-14}
import com.qualcomm.robotcore.hardware.HardwareMap;
import dev.kingssack.volt.robot.Robot;

public class MyRobot extends Robot {
    // Motors
    private DcMotor motor1;

    // Sensors
    private IMU imu;

    public MyRobot(hardwareMap: HardwareMap) {
        super(hardwareMap);
        motor1 = hardwareMap.get(DcMotor.class, "m1");
        imu = hardwareMap.get(IMU.class, "imu");
    }
}
```

</TabItem>

</Tabs>

### 3. Adding Attachments

In Volt, subsystems like an intake mechanism, shooter,
or arm are called `Attachment`s. The `Robot` class is designed to manage these attachments automatically.

To add an `Attachment`, simply declare it as a property within your `Robot` class.
The base `Robot` class will automatically detect all properties of type `Attachment` and add them to a list,
used to manage them.

Let's add an attachment to control our `DcMotor`:

<Tabs>

<TabItem label="Kotlin">

```kotlin {8-9}
class MyRobot(hardwareMap: HardwareMap) : Robot(hardwareMap) {
    // Motor
    private val motor1 by motor("m1")

    // Sensors
    private val imu by imu("imu")

    // Attachments
    val exampleAttachment = DcMotorAttachment("Example", motor1, 0.5, 1000)
}
```

</TabItem>

<TabItem label="Java">

```java
public class MyRobot extends Robot {
    // Motors
    private DcMotor motor1;

    // Sensors
    private IMU imu;

    // Attachments
    public DcMotorAttachment exampleAttachment;

    public MyRobot(hardwareMap: HardwareMap) {
        super(hardwareMap);
        motor1 = hardwareMap.get(DcMotor.class, "m1");
        imu = hardwareMap.get(IMU.class, "imu");
        exampleAttachment = new DcMotorAttachment("Example", motor1, 0.5, 1000, 0, DcMotorSimple.Direction.FORWARD);
    }
}
```

</TabItem>

</Tabs>

### 4. State

The `Robot` class manages its state through a `StateFlow` of type `RobotState`.
This allows you to reactively observe the robot's status from your OpModes. The possible states are:

- `Initializing`: The `Robot` has not finished initializing.
- `Initialized`: The `Robot` has finished initializing, and all attachments have been discovered.
- `Idle`: No attachments are busy.
- `Running`: At least one attachment reports that it is busy.
- `Fault(val error: Throwable)`: An error has occurred.

### 5. The `update()` Method

The `update()` method is called every tick while an OpMode is running.

### 6. Adding `Action`s

The `Robot` class can also declare `Action`s. These can be complex sequences controlling your `Action`s or anything else.

For example let's add a `score` sequence:

<Tabs>

<TabItem label="Kotlin">

```kotlin {11-15}
class MyRobot(hardwareMap: HardwareMap) : Robot(hardwareMap) {
    // Motor
    private val motor1 by motor("m1")

    // Sensors
    private val imu by imu("imu")

    // Attachments
    val exampleAttachment = DcMotorAttachment("Example", motor1, 0.5, 1000)

    // Actions
    fun score() = voltAction(this) {
        +motor1.goTo(0.6, 200)
        +motor1.goTo(0.5, 0)
    }
}
```

</TabItem>

<TabItem label="Java">

```java {18-25}
public class MyRobot extends Robot {
    // Motors
    private DcMotor motor1;

    // Sensors
    private IMU imu;

    // Attachments
    public DcMotorAttachment exampleAttachment;

    public MyRobot(hardwareMap: HardwareMap) {
        super(hardwareMap);
        motor1 = hardwareMap.get(DcMotor.class, "m1");
        imu = hardwareMap.get(IMU.class, "imu");
        exampleAttachment = new DcMotorAttachment("Example", motor1, 0.5, 1000, 0, DcMotorSimple.Direction.FORWARD);
    }

    // Actions
    public Action score() {
        return VoltActionBuilderKt.voltAction(this, (VoltActionBuilder<? super Robot> builder) -> {
            builder.unaryPlus(motor.goTo(0.6, 200));
            builder.unaryPlus(motor.goTo(0.5, 0));
            return kotlin.Unit.INSTANCE;
        });
    }
}
```

</TabItem>

</Tabs>

## Result

<Tabs>

<TabItem label="Kotlin">

```kotlin
package org.firstinspires.ftc.teamcode.robot

import dev.kingssack.volt.attachment.DcMotorAttachment
import dev.kingssack.volt.core.voltAction
import dev.kingssack.volt.robot.Robot
import com.qualcomm.robotcore.hardware.HardwareMap

class MyRobot(hardwareMap: HardwareMap) : Robot(hardwareMap) {
    private val motor1 by motor("m1")
    private val imu by imu("imu")

    val exampleAttachment = DcMotorAttachment("Example", motor1, 0.5, 1000)

    fun score() = voltAction(this) {
        +motor1.goTo(0.6, 200)
        +motor1.goTo(0.5, 0)
    }
}
```

</TabItem>

<TabItem label="Java">

```java
package org.firstinspires.ftc.teamcode.robot;

import com.acmerobotics.roadrunner.Action;  
import com.qualcomm.robotcore.hardware.DcMotor;  
import com.qualcomm.robotcore.hardware.DcMotorSimple;  
import com.qualcomm.robotcore.hardware.HardwareMap;  
import dev.kingssack.volt.attachment.DcMotorAttachment;  
import dev.kingssack.volt.core.VoltActionBuilder;  
import dev.kingssack.volt.core.VoltActionBuilderKt;  
import dev.kingssack.volt.robot.Robot;

public class MyRobot extends Robot {
    private DcMotor motor1;
    private IMU imu;

    public DcMotorAttachment exampleAttachment;

    public MyRobot(hardwareMap: HardwareMap) {
        super(hardwareMap);
        motor1 = hardwareMap.get(DcMotor.class, "m1");
        imu = hardwareMap.get(IMU.class, "imu");
        exampleAttachment = new DcMotorAttachment("Example", motor1, 0.5, 1000, 0, DcMotorSimple.Direction.FORWARD);
    }

    public Action score() {
        return VoltActionBuilderKt.voltAction(this, (VoltActionBuilder<? super Robot> builder) -> {
            builder.unaryPlus(motor.goTo(0.6, 200));
            builder.unaryPlus(motor.goTo(0.5, 0));
            return kotlin.Unit.INSTANCE;
        });
    }
}
```

</TabItem>

</Tabs>
